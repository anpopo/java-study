# Stream
***
## 1. Stream 이란?
- 스트림이란?
  - 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소

  - 연속된 요소
    - 특정 타입으로 이루어진 연속된 값의 집합
    - 컬렉션과의 차이점
      - 컬렉션 - 시간과 공간 복잡성에 기반 데이터의 저장 및 접근이 주를 이룸
      - 스트림 - 연속된 데이터의 계산이 주를 이룸
  - 소스
    - 제공되는 컬렉션에 있는 데이터를 소비한다.
  - 데이터 처리 연산
    - 데이터 조작을 위한 다양한 메소드를 지원한다.
  - 파이프 라이닝
    - 연속된 메소드의 사용으로 연산을 연결 가능
    - 연결된 스트림 덕분에 게으름, 쇼트 서킷 등의 최적화 이점
      - 쇼트 서킷 기법
        - 해당하는 조건식에 대해 최초 1개의 조건에 맞지않는 결과값이 찾아지는 경우 탐색 / 검색을 종료하고 결과를 반환한다.
        - 전체 스트림을 처리하지 않고도 결과값을 반환할 수 있다.
  - 내부 반복
    - 반복자를 명시적으로 지정하는 컬렉션과 다르게 내부 반복을 지원함
    - 값을 하나씩 처리하는 외부 반복에 비해
    - 내부 반복 사용시 작업을 병렬처리 하거나 최적화된 순서로 처리할 수 있다.

## 2. 스트림의 연산
- 스트림의 연산의 종류
  - 중간 연산
    - 파이프 라이닝의 중간을 담당해 stream 의 흐름을 연결하는 연산
    - 중요 특징
      - 중간 연산들을 합치는 과정에서는 아무런 연산이 진짜 실행 되지 않는다.
        - 중간 연산을 합친 후 최종 연산으로 한번에 처리
      - 게으르게 처리한다. 
  - 최종 연산
    - 스트림을 마무리하는 연산


## 3. 스트림 활용
### 3.1 필터링
- Predicate 를 이용한 필터링
  - 람다에서 학습한 FunctionalInterface 인 Predicate 를 인수로 받는 filter() 메소드 사용
- 고유 요소 필터링
  - 고유 요소를 반환하는 메소드 distinct()
  - 스트림을 구성하는 객체의 equals & hashcode 로 결정

### 3.2 슬라이싱
- Predicate 를 이용한 슬라이싱
  - takeWile() 과 dropWhile() 메소드를 활용할 수 있음
  - 원래 소스의 컬렉션의 객체들이 일정 조건에 의해 정렬 되어 있는 경우 사용할 수 있다.
- limit
  - limit(n) 메소드는 n 이하의 크기를 가지는 새로운 stream 을 반환한다.
  - 정렬 되지 않은 스트림에도 limit 을 사용할 수 있다.
    - 다만 정렬이 되지 않은 경우엔 limit 의 결과도 정렬되지 않은채 반환될 수 있다.
- skip
  - skip(n) 메소드는 처음 n 개의 요소를 제외한 스트림을 반환함

### 3.3 매핑
- 특정 객체에서 특정 데이터를 선택하는 작업

- 각 요소에 함수 적용
  - Function 을 인수로 받는 map 함수를 이용
  - 다양하게 활용할 수 있음.
- 스트림 평면화
  - 스트림에 존재하는 콜렉션의 요소들을 평면 리스트로 바꾸어 준다 -> 평면화


### 3.4 검색과 매칭
- Predicate 를 사용해 특정 속성이 주어진 stream 에 있는지 여부를 검사할 수 있다.
- matching
  - anyMatch(), allMatch(), noneMatch()
- searching
  - findFirst(), findAny()