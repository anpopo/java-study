# 자바 학습
인프런 백기선님의 강의를 보고 참고 정리
***
## 1. JVM
### 1.1 자바, JVM, JDK, JRE
- JVM(Java Virtual Machine)
  - 자바 가상머신
  - 자바 바이트 코드(.class 파일)를 os 에 특화된 코드로 변환
  - 특정 플랫폼에 종속적
    - 네이티브 코드로 바꾸어야 하는데 특정 os에 맞춰서 실행해야 하기때문에
  - 여러 벤더에 따라서 JVM의 구현이 가능하다.
    - 오라클, 아마존 등

- JRE(Java Runtime Environment) -> 최소한의 배포단위
  - JVM + 라이브러리
  - 자바 어플리케이션 실행이 목적임
  - 자바의 핵심 라이브러리, 프로퍼티 셋팅 등이 제공된다.
  - 개발을 위한 개발 툴은 포함되어 있지 않다.

- JDK(Java Development Kit)
  - JRE + 개발 툴 (javac, javap 등)
  - 자바 11버전부터 JDK 만 제공한다.
    - JRE 는 역사속으로..
  - 자바 9 부터 모듈 시스템이 사용되었고 모듈 시스템을 이용해 JRE 구성도 가능하다.
  - Write Once Run Anywhere

- Java
  - 프로그래밍 언어
  - JDK에 있는 자바 컴파일러(javac)를 사용하여 바이트 코드(.class) 로 컴파일 할 수 있다.
  - Oracle JDK 11 버전부터 상용으로 사용할 때 유료

- JVM 언어
  - JVM 기반으로 동장하는 프로그래밍 언어
  - Kotlin, 그루비 등


### 1.2 JVM 구조
- 크게 4 개의 컴포넌트로 나뉘어있다.

  - **클래스로더 시스템**
    - 로딩
      - 클래스를 읽어오는 과정
    - 링크
      - 레퍼런스 연결하는 과정
    - 초기화
      - static 값 초기화 및 변수 할당

  - 메모리
    - 전체 공유 자원
      - 힙
        - 객체 저장
      - 메소드
        - 클래스 수준 정보(클래스 이름, 부모 클래스 이름, 메소드, 변수) 저장

    - 쓰레드 공유 자원
      - 스택
        - 스레드마다 런타임 스택을 만들고 메소드 호출 스택 프레임이라 부르는 블럭으로 쌓는다.
        - 스레드 종료시 런타임 스택도 사라진다.
      - PC(Program Counter)
        - 쓰레드 마다 쓰레드 내 현재 실행할 스택 프레임을 가리키는 포인터 생성
      - 네이티브 메소드 스택

  - 실행엔진
    - 인터프리터
      - 바이트 코드를 한줄씩 실행
    - JIT(Just In Time) 컴파일러
      - 바이트코드 -> 네이티브 코드
      - 인터프리터 효율을 높이기 위해 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러로 반복되는 코드를 모두 네이티브 코드로 바꾼다.
      - 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용함.
    - GC(Garbage Collector)
      - 더 이상 참조되지 않는 객체를 모아서 정리

  - JNI(Java Native Interface)
    - native 키워드가 붙은 Interface
    - native 키워드를 사용한 메소드 호출
    - 자바 어플리케이션에서 c, c++, 어셀블리로 작성된 함수를 사용할 수 있는 방법 제공

  - 네이티브 메소드 라이브러리
    - 항상 JNI 를 통해서 사용해야 한다.
    - c, c++로 작성된 라이브러리


### 1.3 클래스 로더
- 로딩 -> 링크 -> 초기화 순서로 진행
- 로딩(loading)
  - 클래스를 읽어오는 과정
  - Bootstrap -> Extension -> Application
  - 클래스 로더가 .class 파일을 읽고 그 내용에 따라 적절한 바이너리 데이터를 만들고 메소드 영역에 저장
  - 이떄 메소드 영역에 저장하는 데이터
    - FQCN(Full Qualified Method Name) -> 풀 패키지 경로, 클래스 이름
    - 클래스 | 인터페이스 | 이넘
    - 메소드와 변수
    - 로딩이 끝나면 해당 클래스 타입의 Class 객체를 생성하여 힙 영역에 저장함.


- 링크 (linking)
  - 레퍼런스(참조값) 연결하는 과정
  - Verify -> Prepare -> Resolve
    - 검증 -> .class 파일 형식이 유효한지 체크
    - preparation -> 클래스 변후(static 변수)와 기본값에 필요한 메모리
    - resolve -> 심볼릭 메모리 레퍼런스를 메소드 영역에 있는 실제 레퍼런스로 교체

- 초기화 (initialization)
  - static 값 초기화 및 변수 할당 (static 블럭이 있다면 이때 실행된다.)

- 클래스 로더는 계층 구조로 이루어 져있으며 기본적으로 3가지 클래스 로더 제공
  - 부트 스트랩 클래스 로더
    - JAVA_HOME/lib 에 있는 코어 자바 API제공
    - 최상위 우선순위를 가진 클래스 로더
  - 플랫폼 클래스 로더(Extension)
    - JAVA_HOME/lib/ext 폴더 또는 java.ext.dirs 시스템 변수에 해당하는 위치에 있는 클래스를 읽음
  - 어플리케이션 클래스 로더
    - 어플리케이션 클래스 패스(어플리케이션을 실행할 때 주는 -classpath 옵션 또는 java.class.path 환경 변수의 값에 해당하는 위치) 에서 클래스를 읽음
    
***
***
## 2. 바이트 코드 조작
### 2.1 코드 커버리지는 어떻게 측정할까
- jacoco 같은 테스트코드 커버리지 툴은 어떻게 할까?
  - 바이트 코드를 분석하고 조작하는 것이 핵심!

### 2.2 모자에서 토끼를 꺼내는 마술
- ASM: https://asm.ow2.io/
- Javassist: https://www.javassist.org/
- ByteBuddy: https://bytebuddy.net/#/  -> 추천
  - 자바 클래스 파일 포맷에 대한 이해가 없어도 api의 사용법을 알면 쉽게 알 수 있다.

### 2.3 javaagent 실습
- 바이트 코드 조작을 위한 자바 에이전트 필요
- 붙이는 방식은 시작시 붙이는 방식 premain 과 런타임 중에 동적으로 붙이는 방식 agentmain이 있다.
- Instrumentation을 사용한다.
- remain 메서드를 구현하면서 바이트 버디 라이브러리 사용
- agent를 jar로 패킹징하면서 jar파일 안에 manifest 를 조작해 특정 값을 넣어준다.
- Javaagent 붙여서 사용하기
  - 클래스로더가 클래스를 읽어올 때 javaagent를 거쳐서 변경된 바이트코드를 읽어들여 사용.

### 2.4 바이트코드 조작 정리
- 프로그램 분석
  - 코드에서 버그를 찾는 툴
  - 코드 복잡도 계산
- 클래스 파일 생성
  - 프록시
  - 특정 api 호출 접근 권한
  - 스칼라 같은 언어의 컴파일러
- 그 외 자바 소스 코드를 건드리지 않고 소스 코드 변경이 필요한 여러 경우에 사용 가능
  - 프로파일링
  - 최적화
  - 로깅

- 스프링이 컴포넌트 스캔(@ComponentScan)을 하는 방법(스프링은 asm 사용)
  - 컴포넌트 스캔으로 빈으로 등록할 후보 클래스 정보를 찾는데 사용
  - ClassPathScanningCandidateComponentProvider -> SimpleMetadataReader
  - ClassReader와 Visitor 사용해서 클래스에 있는 메타 정보를 읽어온다. 


